#想法：考虑搜索算法，而每个节点的子节点数量不一定一致，且对单个节点的树深度在变化，且只求一个最最近解，不是求所有解，因此用BFS
#官网想法：首先假设只有1个0，以其为起点进行BFS，广度优先搜索可以找到从起点到其余所有点的最短路径，因此每搜到一个1就得到0到这个1的最短路径。但实际中有多个0，因此假设有个超级节点，其所有
# 子节点是所有的0，以这个超级节点为树的头结点开始进行BFS。首先对超级节点扩展，弹出超级节点，将其所有子节点放入队列。即将所有0加入队列。然后在这个树的基础上进行常规的BFS即可。扩展原则是向
# 四周扩展，已扩展得不再扩展，扩展过的已得到离0最近距离。（由于是从所有0开始向四周层序遍历，即已扩展的就已经得到了到最近0的距离）

#代码：首先得到输入矩阵height，width，创立存放结果的矩阵re和上下左右的偏移量dx[-1,0,0,1]，dy[0,-1,1,0]，re内元素值为10000或inf（题中说矩阵元素不超过10000，因此最大距离不超过10000）
       利用for循环将0节点加入队列
       while循环内进行扩展：
          取出队列头节点，得到位置x，y
          若取出的节点是0，其周围的re设为1，并加入队列（四周节点用for循环结合dx，dy遍历）
          若取出的节点是1,从四周找最小值，其值为最小值+1，并把四周未扩展节点加入队列(re是10000的)
          （中间注意for循环内若四周元素越界就continue）
       返回re
