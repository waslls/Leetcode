#具体分析见goognotes的力扣经典题目
#虽是广度优先的题目，但是官方题解给出深度优先搜索和两种图算法（dijkstra和Bellman-Ford算法），借助b站Ronan0的解法即官网，首先采取BF算法解答(较好理解)
#解法1：BF算法，做顶点次数减1的循环，每次循环松弛所有的边(边顺序不影响最后结果)，我猜因为每次循环至少能找到一个节点距起点的最短路径（也可能因为最外层的k表示计算起点k步之内可达到的最短路径，
因此要计算起点离所有顶点的最短路径需要循环V-1次，V为顶点个数）。
  由于题目要计算最多经k次中转达到目标的最短路径，因此到终点最多走k+1步，所以做一个外层循环次数为k+1的BF算法即可。
  但这个思想存在问题，就是经k次循环，找到的不止是k步内的最短路径，很可能找到k步外的最短路径，所以不适用这题。
  
  官方里也是用BF算法，不同点在于加入了k状态，即用dp[i][k]表示从起点到i节点最多经k站的最小代价，且第一轮只对从起点出发的边进行松弛（起点到起点的初始化为0），每次只对上一轮得到单源最短路径
  的节点才进行松弛。这是和普通BF不同的地方。不同于BF每一轮对所有边都松弛，导致第i轮可能就能求得经i-1步之外的节点的最短路径。即题目给出k，但求的结果是经过比k个节点多的最短路径。具体见提交
  3的反例（在力扣经典题目）。还是需要定义带k信息的状态数组，避免对本轮更新过的终点作为起点的边错误更新。
