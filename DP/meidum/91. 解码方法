#最初思路是看当前数字是否是0（dp[i]表示s[:i]的解码方法数），若是则判断前一个数是否是1或2，若不是返回0，若是还要判断前一个数的前一个数是否是1或2，若是dp[i] = dp[i-1]-1，等等很麻烦而且总是会出现漏掉的情况

#官方：若使用s[i]解码，则只要s[i]！=0，dp[i]=dp[i-1]（若=0，要么使用两个数字解码 要么不存在解码方式，则不用管，因为dp数组初始化为0）；若使用s[i−1]和s[i]解码，若s[i−1]！=0且s[i−1]和s[i]组成的
#数字在1-26间，dp[i]=dp[i-2]（这种情况需要i>=2），最终dp[i]为上面两种情况之和。

#note！！！：这里有个特殊情况，就是当i=1时，即字符串有两位时，dp[i]=dp[i-2]也是需要执行的，比如'10'，所以应该给0前一位即索引为-1的位置赋值1，但python的dp[-1]和这里含义不同，因此整个dp数组向后
#移一位，dp[0]代表索引为-1的情况，值为1.
#因此代码有两种写法，一种（自己）是初始化dp[0]和dp[1]都=1，然后for循环从2到n+1(n=len(s))，且在使用s[i−1]和s[i]解码时不用再判断i>=2了，另一种(官方)是只初始化dp[0]=1，for循环从1到n+1，这种情况
#需要判断i>=2
