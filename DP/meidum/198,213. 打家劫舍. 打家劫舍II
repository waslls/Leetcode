#首先考虑只有一个房屋时，肯定偷，两个时，偷大的那个，设dp[i]为前i+1个房屋偷到的最高金额，则若第i个偷，则第i-1个不能偷，dp[i] = dp[i-2]+nums[i]，若第i个不偷，dp[i] = dp[i-1]，初始条件dp[0]=
#nums[0].实际情况在第二个的时候只求第一个和第二个最大值，不存在dp[i-2]，所以将dp[0]设置为0，表示无村庄抢劫0元，这样所有dp[i]都往后移动一位，对应的forloop里的nums[i]要写为nums[i-1].

#对于II，第一个和最后一个相互影响，若第一个选，则最后一个不能选，将上面算法输入数组改为nums[:-2],若第一个不选，则最后一个不受影响，数组改为nums[1:]，求这两个最大值即可（注意输入长度小于2时不用考虑第一个选不选）
